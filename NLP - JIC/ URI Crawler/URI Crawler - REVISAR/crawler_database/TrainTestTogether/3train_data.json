[
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1253",
        "saida": "Para cada caso de teste de entrada, imprima uma linha de saída com o texto decodificado (transformado novamente para o texto original) conforme as regras acima e o exemplo abaixo.",
        "descricao": "Júlio César usava um sistema de criptografia, agora conhecido como Cifra de César, que trocava cada letra pelo equivalente em duas posições à direita no alfabeto (por exemplo, 'A' vira 'C', 'R' vira 'T', etc.). Ao fim do alfabeto nós voltamos para o começo, isto é 'Y' vira 'A'. Nós podemos, é claro, tentar trocar as letras com quaisquer número de posições.",
        "titulo": "Cifra de César",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste. Cada caso de teste é composto por duas linhas. A primeira linha contém uma string com até 50 caracteres maiúsculos ('A'-'Z'), que é a sentença após ela ter sido codificada através desta Cifra de César modificada. A segunda linha contém um número que varia de 0 a 25 e que representa quantas posições cada letra foi deslocada para a direita."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1235",
        "saida": "Para cada linha de entrada deverá ser impressa uma linha de saída com a frase decifrada, conforme a especificação acima.",
        "descricao": "A sua impressora foi infectada por um vírus e está imprimindo de forma incorreta. Depois de olhar para várias páginas impressas por um tempo, você percebe que ele está imprimindo cada linha de dentro para fora. Em outras palavras, a metade esquerda de cada linha está sendo impressa a partir do meio da página até a margem esquerda. Do mesmo modo, a metade direita de cada linha está sendo impressa à partir da margem direita e prosseguindo em direção ao centro da página. Por exemplo a linha: THIS LINE IS GIBBERISH está sendo impressa como: I ENIL SIHTHSIREBBIG S Da mesma foma, a linha \" MANGOS \" está sendo impressa incorretamente como \"NAM  SOG\". Sua tarefa é desembaralhar (decifrar) a string a partir da forma como ela foi impressa para a sua forma original. Você pode assumir que cada linha conterá um número par de caracteres.",
        "titulo": "De Dentro para Fora",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste. Seguem N linhas, cada uma com uma frase com no mínimo 2 e no máximo 100 caracteres de letras maiúsculas e espaços que deverá ser desembaralhada (decifrada) à partir da forma impressa para a sua forma original, conforme especificação acima."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1491",
        "saida": "Para cada caso de teste imprima N linhas, cada uma delas contendo um inteiro. Na enésima (i-th) linha escreva o número máximo de casos de compatibilidade das ocorrências de T nas enésimas (i-th) seleções de substring, considerando todas as inversões de case feitas pelas seleções anteriores. Se tal ocorrência não existir, imprima o valor −1.",
        "descricao": "Brenda, neta de Benjamin, tem um blog onde ela posta artigos sobre a escola, os amigos e outras questões da vida. Intrigado com suas opiniões, Benjamin tentou lê-lo, mas logo se deu conta de que era muito difícil de ler por causa das peculiaridades da escrita de Brenda. Brenda escreve sem espaços ou sinais de pontuação, e, além disso, ela usa letras minúsculas e maiúsculas de uma forma liberal e estranha. Por exemplo, uma das suas mensagens é \"PrOgRAMmINgiSgrEAt\". Benjamin tem dificuldade em perceber as palavras \"programming\", \"is\" e \"great\" quando são escritos desta forma. Para melhorar a sua compreensão, Benjamin decidiu fazer o seguinte: ele vai primeiro escolher uma determinada string T e um post do blog no qual ele está interessado e, em seguida, ele irá selecionar uma substring contígua do post e irá procurar T dentro da substring, de uma forma case-insensitive. Para cada ocorrência de T dentro da substring, ele vai calcular o número de incompatibilidade de case e, finalmente, ele vai obter o máximo entre todos esses valores. Por exemplo, se Benjamin escolhe \"GR\", como T e, em seguida, seleciona a substring \"“PrOgRAM\", ele iria encontrar uma ocorrência única \"gR\" para o qual o número de incompatibilidade de case é 1. Pela mesma subsequência, se \"r\" foi escolhido como T, ele teria encontrado duas ocorrências, \"r\" com 0 incompatibilidades e \"R\", com uma incompatibilidade, portanto, o número máximo de incompatibilidades seria 1. Para complicar mais as coisas, Brenda incluíu no blog um script que, depois da operação com a seleção de uma substring, inverte o \"case\" de todas as letras selecionadas. Isto significa que após selecionar “PrOgRAM” e proceder como explicado acima, o post exemplo seria lido como “pRoGrammINgiSgrEAt”. Se Benjamin seleciionar “ammINgi” como uma segunda substring, após calcular o seu resultado o post será deixado como “pRoGrAMMinGISgrEAt”, acumulando as duas inversões. Você receberá a string T e o texto original do post do blog escolhido por Benjamin. A você serão também fornecido uma lista com as seleções de substring feitas por Benjamin, a fim de fazê-las. Você precisa calcular, para cada seleção, o número máximo de cases incompatíveis das ocorrências de T na parte selecionada, considerando todas as inversões feitans pelas seleções anteriores. Observe que a inversão de case ocorre após o cálculo do resultado de cada seleção.",
        "titulo": "Linguagem de Blogger",
        "entrada": "A entrada contém vários casos de teste e termina com EOF.  A primeira linha de um caso de teste contém um N (1 ≤ N ≤ 105 ) e uma string não vazia T com no máximo 5 letras, representando respectivamente o número de seleções de substring e a string a ser selecionadar. A segunda linha contém uma string não vazia P com no máximo 105 letras, indicando o texto original postado no blog. Posições do post são numerados com inteiros consecutivos da esquerda para a direita, sendo 1 a posição mais à esquerda e |P| a posição mais à direita. Cada uma das próximas N linhas descreve uma seleção de substring com 2 inteiros L e R (1 ≤ L ≤ R ≤ |P|) indicando que a substring inicia na posição L e termina na posição R, inclusive."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1781",
        "saida": "Para cada caso imprima “Caso #X:”, onde X é o número do caso atual, começando em 1. Para cada operação 2, imprima em uma nova linha como a string S se encontra depois de todas as operações anteriores terem sido executadas. A saída possui aproximadamente 3*10⁶ caracteres.",
        "descricao": "Guga tem uma string S contendo apenas letras minúsculas e quer fazer operações nela. Cada operação pode ser de um dos seguintes tipos: 0 x, deslocar cada vogal de S x posições da esquerda pra direita (voltando para o começo, caso necessário) 1 x, deslocar cada consoante de S x posições da esquerda pra direita (voltando para o começo, caso necessário) 2, imprimir como S se encontra atualmente As vogais que estamos considerando são as letras a, e, i, o e u. Uma operação do tipo 0 só desloca vogais por posições de S que possuem vogais. Uma operação do tipo 1 só desloca consoantes por posições de S que possuem consoantes. Por exemplo, A string “computador” após a operação 1 2 fica “dorcumapot”, ou seja, cada consoante vai para a posição em S da segunda próxima consoante. A string “abe” após a operação 0 1, fica “eba”.",
        "titulo": "Guga e a String",
        "entrada": "A primeira linha da entrada contém T (1 ≤ T ≤ 100), o número de casos de teste. A primeira linha de cada caso de teste possui S (1 ≤ |S| ≤ 10⁴), a string que Guga possui. A segunda linha de cada caso possui Q (1 ≤ Q ≤ 10⁵) , o número de operações que Guga irá executar em S. Cada uma das próximas Q linhas possuem uma operação como explicado acima. Para cada operação, 0 ≤ x ≤ |S|."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "2049",
        "saida": "Para cada instância solucionada, você deverá imprimir um identificador \"Instancia h\" em que h é um número inteiro, sequencial e crescente a partir de 1. Na linha seguinte, você deverá imprimir \"verdadeira\" se a sequência de números contém a assinatura do artista ou \"falsa\" em caso contrário. Uma linha em branco deve separar a saída de cada instância.",
        "descricao": "Antes da colonização hispânica e depois inglesa, a região de San Antonio era dominada pelos índios ahmoc-axhozupeck, ancestrais dos sioux e dos apaches. A etnia foi completamente destruída pelos colonizadores, no século XVIII, tornando impossível a tarefa de decifrar seus grandes painéis. O Departamento de Arqueologia da Universidade Baylor dedica boa parte de sua pesquisa aos painéis dos índios Ahmoc. Surpreendentemente os índios já conheciam os algarismos hindus, mas não o usavam para cálculos (afinal não existia comércio naquela civilização). Os arqueólogos de Baylor suspeitam que os painéis repletos de números fossem apenas decorativos. Também suspeitam que alguns padrões que se repetiam eram assinaturas dos artistas, a fim de garantir a autenticidade do painel. Sua tarefa neste problema será verificar se os painéis são verdadeiros, ou seja, se, de fato, contêm a assinatura do artista que o arqueólogo suspeita ser o autor.",
        "titulo": "Números de Ahmoc",
        "entrada": "São dadas várias instâncias de teste. Cada instância começa com um número inteiro positivo 0 ≤ a ≤ 1000000 que é a assinatura do artista. O inteiro 0 indica o fim dos dados. Na linha seguinte vem a sequência de números do painel, que poderá ter até 300000 algarismos."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "1607",
        "saida": "Para cada caso imprima o número mínimo de operações.",
        "descricao": "É dado na entrada uma string A e outra B. Em uma operação você pode escolher uma letra da primeira string e avançar esta letra. Avançar uma letra significa transformá-la na próxima letra do alfabeto, veja que a próxima letra depois de z vem a letra a novamente! Por exemplo, podemos transformar a string ab em bd em no mínimo 3 operações: ab -> bb -> bc -> bd. Podemos aplicar operações nas letras em qualquer ordem, outra possibilidade seria: ab -> ac -> bc -> bd. Dadas as duas strings, calcule o mínimo número de operações necessárias para transformar a primeira na segunda.",
        "titulo": "Avance as Letras",
        "entrada": "Na primeira linha terá um inteiro T (T ≤ 100) indicando o número de casos de teste. Para cada caso, na única linha teremos as duas strings A (1 ≤ |A| ≤ 100* ou 1 ≤ |A| ≤ 104** - sendo que |A| significa o tamanho da string A) e B (|B| = |A|* ou |B| = |A​|**) separadas por um espaço. Ambas as strings são compostas por letras do alfabeto minúsculas apenas e são do mesmo tamanho. *Ocorre em aproximadamente 90% dos casos de teste; **Ocorre nos demais casos de teste."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1249",
        "saida": "Para cada linha da entrada, imprima uma linha na saída com a mensagem cifrada pelo método rot13.",
        "descricao": "Escreva um programa que receba uma mensagem \"secreta\" e retorne esta mensagem codificada. A mensagem é codificada com uma cifra chamada rot13. Rot13 funciona da seguinte maneira, é atribuido para cada letra um índice, baseado em sua posição no alfabeto. a = 1, b = 2, c = 3, ..., z = 26. Cada letra da mensagem deve ser deslocada 13 posições para a direita, se o fim do alfabeto for atingido, a contagem recomeça no primeiro caracter do alfabeto. Por exemplo, o caracter \"a\" (aspas apenas para evidenciar), seria mapeado para \"n\", \"y\" para \"l\", \"f\" para \"s\", e assim por diante. O mesmo processo é feito para letras maiúsculas também. Quaisquer caracteres não-alfabéticos devem ser repassados para a saída sem alterações.",
        "titulo": "Rot13",
        "entrada": "A entrada contém vários casos de teste e termina com final de arquivo (EOF). Cada caso de teste consiste de uma linha que contém uma mensagem com no mínimo 1 no máximo 50 caracteres inclusive, contendo letras, números, e os símbolos: !@#$%^&*()-_=+[]{}|;':,./?\""
    },
    {
        "nivel": "7",
        "assunto": "3",
        "numero": "1686",
        "saida": "Para cada caso de teste imprima uma linha com o valor máximo de uma seqüência de palíndromos com deslocamento D na string S.",
        "descricao": "Dada uma string s[1..N], definimos uma sequência de palíndromos de tamanho p e deslocamento d (1 = 1) substrings disjuntas em s (cada sequência sendo um palíndromo de tamanho p) e com distâncida d entre caracteres nos diferentes palíndromos. Formalmente, essas sequências disjuntas em S formam um conjunto : A= (s[i..i+p-1], s[i+d..i+d+p-1], s[i+2d..i+2d+p-1], ...) onde cada elemento de A é um palíndromo de tamanho p. Lembre-se que um palíndromo é uma sequência que pode ser lida do mesmo jeito do começo para o fim e do fim para o começo. O valor de uma sequência de palíndromos é o número total de caracteres usados de S (Se a sequência de k palíndromos de tamanho p, seu valor será k*p). Fixado um deslocamento D e dada uma string S, calcule a sequência de palíndromos de maior valor contida em S",
        "titulo": "Sequência de Palíndromos",
        "entrada": "Cada entrada é descrita por 2 linhas. A primeira linha contém dois inteiros N e D (1 <= N <=10^5), 1 <= D <=10^5) representando, respectivamente, o tamanho da string e o valor do deslocamento. A segunda linha contém N caracteres minúsculos formando a string S. A última entrada contém dois zeros."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1335",
        "saida": "Para cada caso de teste imprima uma linha com um inteiro representando o número de conjuntos não-vazios pesquisáveis.",
        "descricao": "O sistema operacional do seu computador indexa os arquivos do seu disco rígido baseado no seu conteúdo, e provê busca textual sobre eles. O conteúdo de cada arquivo é uma cadeia não-vazia de caracteres minúsculos. Para realizar uma pesquisa, você especifica uma chave, que é também uma cadeia não-vazia de letras minúsculas. O resultado é uma lista de todos os arquivos que contém a chave como uma subcadeia. Uma cadeia s é uma subcadeia de uma cadeia t se t contém todos os caracteres de s como uma sequência contígua. Por exemplo, \"foofoo\", \"cafoo\", \"foota\" e \"foo\" todas contém \"foo\" como uma subcadeia, enquanto \"foa\", \"fofo\", \"fioo\" e \"oofo\" não contém. Você sabe o conteúdo de cada arquivo no seu disco rígido, e gostaria de saber se cada subconjunto dos arquivos é pesquisável. Um subconjunto dos arquivos é pesquisável se existe pelo menos uma chave que produz exatamente a lista desses arquivos como resultado. Dado os conteúdos dos arquivos on seu disco rígido, você deve computar o número de subconjuntos não-vazios pesquisáveis.",
        "titulo": "Recuperação de Arquivos",
        "entrada": "Cada caso de teste é descrito usando várias linhas. A primeira linha contém um inteiro F representando o número de arquivos do seu disco rígido (1 ≤ F ≤ 60). Cada uma das F linhas sequintes indica o conteúdo de um dos arquivos. O conteúdo de um arquivo é uma cadeia não-vazia de no máximo 104 caracteres; cada caracteres é uma das 26 letras minúsculas (de 'a' até 'z'). O último caso de teste é seguido por uma linha contendo um zero."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1239",
        "saida": "Para cada linha de entrada seu programa deve gerar uma linha de saída com o texto traduzido para HTML como demonstrado nos exemplos abaixo. Para tornar itálico um pedaço de texto no HTML, você deve iniciar este pedaço com a tag e terminá-lo com a tag . Para texto em negrito, inicie com e termine com . O final da entrada é determinado por EOF.",
        "descricao": "Você está ajudando a desenvolver um sistema de gerenciamento de weblog chamado bloggo. Embora bloggo coloque todo o conteúdo direto no website em HTML, nem todos autores apreciam usar tags HTML em seus textos. Para tornar a vida deles mais fáceis, bloggo oferece uma sintaxe simples chamada atalhos para obter alguns efeitos textuais em HTML. Sua tarefa é, dado um documento escrito com atalhos, traduzi-lo para o HTML apropriado. Um atalho é usado para colocar texto em itálico. HTML faz isto com as tags e , mas no bloggo um autor pode simplesmente colocar um pedaço de texto entre dois caracteres de sublinhado, '_'. Portanto, onde um autor escreve You _should_ see the baby elephant at the zoo! bloggo vai publicar o seguinte: You should see the baby elephant at the zoo! Outro atalho serve para colocar texto em negrito, o que, em HTML, é feito com as tags e . Bloggo permite aos autores fazer o mesmo com pares do caractere asterisco, '*'. Quando um autor escreve o texto Move it from *Receiving* to *Accounts Payable*. ele vai sair no website assim: Move it from Receiving to Accounts Payable.",
        "titulo": "Atalhos Bloggo",
        "entrada": "A entrada contem vários casos de teste. Cada caso de teste é composto por uma linha que contem uma string texto, com zero ou mais usos dos atalhos itálico e negrito. Cada texto tem de 1 a 50 caracteres, inclusive. Os únicos caracteres permitidos no texto são os caracteres alfabéticos (de 'a' a 'z' e de 'A' a 'Z'), o sublinhado ('_'), o asterisco ('*'), o caractere de espaço e os símbolos de pontuação ',', ';', '.', '!', '?', '-', '(' e ')'. O caractere sublinhado '_' ocorre no texto um número par de vezes. O asterisco '*' também aparece um número par de vezes no texto. Nenhuma substring do texto entre um par de sublinhados ou entre um par de asteriscos pode conter outros sublinhados ou asteriscos, respectivamente."
    },
    {
        "nivel": "6",
        "assunto": "3",
        "numero": "2097",
        "saida": "Escreva o número inteiro correspondente ao nome.",
        "descricao": "Dada uma lista de nomes de números, converta-os para inteiros. Talvez o problema  número 1846 do URI ajude você.",
        "titulo": "Nome para Número",
        "entrada": "Em cada linha (cerca de 100000 linhas), há o nome de um número inteiro n, 0 ≤ n ≤ 1015-1."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1262",
        "saida": "Para cada caso de teste determine e imprima o número mínimo de ciclos de máquina necessários para se processar o rastro informado. Vide exemplos abaixo.",
        "descricao": "Em diversos sistemas de computação, vários processos podem ler de um mesmo recurso durante o mesmo ciclo de máquina, mas somente um processo pode escrever no recurso durante o ciclo de máquina. Leituras e gravações não podem se misturar em um mesmo ciclo de máquina. Dado um histórico de leituras e gravações que ocorreram durante a execução de um determinado processamento, e um número inteiro que representa o número de processos usados, calcule a duração mínima do processamento, em ciclos de máquina. O rastro de histórico representa cada leitura por uma letra 'R' e cada gravação por uma letra 'W'. Por exemplo, se o rastro de histórico é \"RWWRRR\" e o número de processos é 3, então o número mínimo de ciclos de máquina será 4: um para a primeira leitura, um para cada uma das gravações e apenas um para todo o último grupo de leituras.",
        "titulo": "Leitura Múltipla",
        "entrada": "A entrada contém diversos casos de testes. Cada caso é composto por duas linhas. A primeira linha contém o rastro de processamento em uma sequência de caracteres 'R' ou 'W' formando um String de 1 a 50 caracteres. A segunda linha contém um valor inteiro P (1 ≤ P ≤ 10), representando o número de processos, ou seja, uma indicação de quantas operações de leitura podem ser processadas simultaneamente. A entrada termina em EOF."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1238",
        "saida": "Combine as duas cadeias de caracteres da entrada como mostrado no exemplo abaixo e exiba a cadeia resultante.",
        "descricao": "Implemente um programa denominado combinador, que recebe duas strings e deve combiná-las, alternando as letras de cada string, começando com a primeira letra da primeira string, seguido pela primeira letra da segunda string, em seguida pela segunda letra da primeira string, e assim sucessivamente. As letras restantes da cadeia mais longa devem ser adicionadas ao fim da string resultante e retornada.",
        "titulo": "Combinador",
        "entrada": "A entrada contém vários casos de teste. A primeira linha contém um inteiro N que indica a quantidade de casos de teste que vem a seguir. Cada caso de teste é composto por uma linha que contém duas cadeias de caracteres, cada cadeia de caracteres contém entre 1 e 50 caracteres inclusive."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1364",
        "saida": "Para cada caso de teste, imprima exatamente uma linha contendo um único inteiro que indica o número mínimo de mudanças que você precisa fazer para ter certeza de que nenhum emoticon apareça no texto.",
        "descricao": "Emoticons são usados em chats e conversações por e-mail para tentar expressar a emoção que palavras impressas não podem. Isso parece interessante para muitos, mas outros acham irritantes e querem se livrar deles. George é uma dessas pessoas. Ele odeia tanto emoticons que ele está preparando um plano para remover todos os emoticons de todos os e-mails do mundo. Já que você compartilha de seus planos visionários você está preparando um programa especial para ele. Seu programa receberá a lista de emoticons para banir. Cada emoticon será uma sequência de caracteres sem incluir qualquer espaço em branco. Você também receberá várias linhas de texto. O que você precisa fazer é mudar alguns caracteres do texto em espaço para certificar-se de que nenhum emoticom ficará no texto. Para um emoticon poder aparecer no texto, é necessário ter uma sequência especial de caracteres consecutivos. Para ajudar o plano de George a manter-se oculto o mais tempo possível, você precisa fazer seu trabalho com o mínimo possível de mudança nos caracteres.",
        "titulo": "Emoticons :-)",
        "entrada": "A entrada contém vários casos de teste. Cada teste consiste em várias linhas. A primeira linha de cada caso de teste conterá dois inteiros separados por um espaço: N, o número de emoticons a proibir, e M, o número de linhas que o texto tem. As próximas N linhas contém um emoticon cada, uma sequência (string) \"não vazia\" de no máximo quinze caracteres. Cada uma das últimas M linhas do caso de teste contém uma linha de texto de no máximo oitenta caracteres. Você pode assumir que 1 ≤ N, M ≤ 100. Caracteres válidos para emoticons são letras maiúsculas e minúsculas, dígitos e símbolos “!?.,:;-_’#$%&/=*+(){}[]” (aspas para demarcar). Cada linha do texto deve conter os mesmos caracteres com a adição de um caractere \"espaço\". A entrada é terminada por N = M = 0."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1803",
        "saida": "A saída é dada em uma única linha e corresponde a string decodificada. Inclua o caractere de fim-de-linha após a string.",
        "descricao": "Matring é uma mistura de Matriz e String. Ela foi desenvolvida pela UNILA (União dos Nerds para Integração da Lógica e da Aventura) para manter mensagens seguras de escutas. A primeira e última coluna de uma matring guarda a chave para traduzi-la na mensagem original. As colunas restantes de uma matring representam uma string codificada em ASCII, uma coluna por caractere. Para uma mensagem com N caracteres, a matring correspondente é uma matriz 4x(N+2) de dígitos. Cada coluna é lida como um número de 4 dígitos; uma sequência de dígitos de cima para baixo é o mesmo que uma sequência de dígitos da esquerda para a direita na horizontal. Seja o primeiro número F, o último número L e os restantes uma sequência de números Mi, onde 1 ≤ i ≤ N. A primeira coluna de uma matring é indexada por zero. Para decodificar uma matring para uma string, calculamos: Ci = (F * Mi + L) mod 257, onde Ci é o caractere em ASCII na posição i da mensagem original. Sua tarefa é desenvolver um algoritmo para decodificar matrings.",
        "titulo": "Matring",
        "entrada": "A entrada é uma matring, ou seja, uma matriz 4x(N+2) de dígitos (de 0 a 9) com 0 < N < 80."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1278",
        "saida": "Para cada caso de teste imprima o texto com apenas um espaço entre as palavras, e inserindo tantos espaços quanto forem necessários à esquerda de cada linha do texto, para que elas apareçam alinhadas à margem direita daquele texto, e na mesma ordem da entrada. Deixe uma linha em branco entre os casos de testes. Não imprima espaços no final de cada linha, nem espaços desnecessários à esquerda, de modo que pelo menos uma das linhas impressa em cada texto inicie com uma letra.",
        "descricao": "Nós temos alguns textos e queremos formatá-los e justificá-los à direita, ou seja, alinhar suas linhas à margem direita de cada um. Crie um programa que, após ler um texto, reimprima esse texto com apenas um espaço entre as palavras e suas linhas justificadas à direita em todo o texto.",
        "titulo": "Justificador II",
        "entrada": "A entrada contém diversos casos de teste. A primeira linha de cada caso de teste contém um inteiro N (1 ≤ N ≤ 100) que indica o número de linhas de texto que virão a seguir. Cada uma destas N linhas de texto contém de 1 a 50 letras maiúsculas (‘A’-‘Z’) ou espaços (‘ ’). Todas as linhas de texto contém no mínimo uma letra. Poderá haver mais de um espaço entre as palavras. É também possível haver espaços no início e no final da linha. O fim da entrada é indicado por N = 0."
    },
    {
        "nivel": "8",
        "assunto": "3",
        "numero": "1853",
        "saida": "Imprima una única linha contendo Tyrion se Tyrion pode derrotar Daenerys, ou Daenerys caso contrário.",
        "descricao": "Daenerys: \"(...) então eu deveria deixá-lo me servir porque você assassinou membros de sua própria família?\" Tyrion: \"Lhe servir? Majestade, nós acabamos de nos conhecer. É muito cedo para saber se você merece meus serviços.\" Para acertar as coisas com o anão, Daenerys decidiu desafiar Tyrion para um jogo de 2 jogadores que ela mesma inventou, quando estava no mar Dothraki. Se Tyrion vencê-la no jogo, ela irá fazer dele seu conselheiro, como ele queria. Caso contrário, ela irá mandar executá-lo. Este é um jogo com palavras. Neste jogo, considera-se apenas o alfabeto Dothraki, que consiste nas primeiras L letras minúsculas do nosso alfabeto. O jogo se inicia com uma lista de S strings s1, ..., sS. A partida é jogada por turnos, e Tyrion é o primeiro a jogar. Em cada turno, um jogador escolhe uma string da lista e adiciona uma letra (do alfabeto Dothraki) ao final da string, em seu lado direito.  Entretanto, um jogador não pode adicionar uma letra a uma string si (1 ≤ i ≤ S) se Fi letras já foram adicionadas à string durante o jogo. Um jogador também não pode adicionar uma letra a uma string se esta string, incluindo todas as letras adicionadas a ela durante o jogo (mas não a letra que o jogador quer adicionar), contém um adjetivo Dothraki como substring. Todos os adjetivos Dothraki são dados na entrada. Se um jogador não puder adicionar nenhuma letra a nenhuma string, ele perde o jogo. Tanto Daenerys quanto Tyrion jogam de forma ótima. Sua tarefa é decidir se Tyrion pode vencer Daenerys neste jogo. No primeiro exemplo, Tyrion pode vencer se adicionar a letra c à string s1: ela conterá um adjetivo e logo não poderá mais ser escolhida. Daenerys é forçada a adicionar uma letra à string s2. Tyrion então adicionará outra letra a s2.  Neste ponto, Daenerys não terá mais opções de jogadas, pois F2 = 2 letras já foram adicionadas à string s2.",
        "titulo": "O Jogo da Confiança de Daenerys",
        "entrada": "A primeira linha da entrada contém os inteiros D e L (D > 0, 2 ≤ L ≤ 10), onde D é o número de adjetivos Dothraki. Cada uma das próximas D linhas contém um adjetivo. A soma dos tamanhos de todos os adjetivos não será maior que 105. A próxima linha contém o número S (1 ≤ S ≤ 300). Cada uma das próximas S linhas contém uma string si e o inteiro Fi (1 ≤ Fi ≤ 50). A soma dos tamanhos de todas as strings si não será maior que 3×103. É garantido que nenhuma dessas strings contém um adjetivo Dothraki.  Além disso, todos os adjetivos e todas as strings si contém apenas letras do alfabeto Dothraki."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1385",
        "saida": "Para cada caso de teste da entrada seu programa deve produzir um possível relatório de Maria. Cada linha da resposta deve ser alinhado à esquerda, com seus itens separados por um único espaço, e sem espaços a mais no final.",
        "descricao": "No final da semana, John pediu para Maria enviar-lhe um relatório urgente de vendas. Maria estava com pressa, porque estava saindo para suas férias. Ela, então, copiou e colou a folha de vendas em um e-mail, enviou para John e saiu. Ela não queria ser incomodada com questões de trabalho, de modo que ela saiu sem dizer a ninguém onde ela estaria. Ela anunciou simplesmente que não estaria disponível para as próximas duas semanas, desligou o celular e saiu. Quando João recebeu a mensagem, ele percebeu que o relatório não tinha nenhum espaço! Ele sabia que o relatório deveria ter uma linha de cabeçalho com códigos de produtos da forma P1, P2,. . ., PN e a palavra \"Totals\" (Totais) no final. Então haveria várias linhas de relatórios de vendas de produtos para os diferentes vendedores de escritório de Maria. Cada vendedor foi identificado com um nome composto por uma palavra (apenas caracteres alfabéticos). A linha correspondente a um vendedor deve começar com o seu nome, seguido do número de produtos vendidos, de acordo com as colunas do relatório. A última linha do relatório deve começar com as duas letras TP seguidos pelos totais de cada coluna no relatório (é claro, o nome de nenhum vendedor começa com as letras TP). John sabia que não havia números negativos no relatório, uma quantidade de zero foi avaliado como um único 0, e não há zeros à esquerda ao relatar uma quantidade positiva. Neste ponto, John decidiu reconstruir o relatório de Maria. Ele sabia que não poderia ser mais de um resultado possível, mas queria fazê-lo de qualquer maneira com a primeira solução consistente que ele poderia encontrar (talvez ele pudesse corrigir os erros quando Maria voltasse). Você poderia ajudar John com a recuperação de relatório de vendas de Maria?",
        "titulo": "Recuperação de Relatório",
        "entrada": "A entrada consiste em vários casos de teste. A primeira linha de entrada contém um número inteiro C especificando o número de casos de teste. A primeira linha de um relatório é uma linha de cabeçalho, contendo o código dos produtos P1, P2. . . PN e a palavra Totais, como descrito acima. A numeração dos produtos nesta linha de cabeçalho é consecutiva, de 1 a N, com 1 ≤ N ≤ 5. Depois, há um número de linhas, cada uma representando uma linha do relatório, como descrito acima. A última linha do relatório inicia com as letras TP e têm o formato descrito acima. Considere que cada vendedor tenha vendido menos de 1000 unidades de cada produto. Há não mais de 4 vendedores em cada caso de teste. Cada nome de vendedor não poderá exceder 10 caracteres (apenas letras maiúsculas e minúsculas)."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "2137",
        "saida": "Seu programa deverá imprimir o cadastro dos códigos ordenado. Não haverá linha em branco entre os casos de teste.",
        "descricao": "Em uma pacata cidade do interior, o senhor Severino decidiu montar a própria biblioteca, já que coleciona vários livros desde sua juventude. Como ele não sabe programar, pediu ajuda ao neto para criar um programa que cadastre e ordene seus livros pelo código. Porém, seu neto ainda está no ensino fundamental, e como sabe muito pouco de programação, acabou criando um programa que somente cadastra os livros, mas não os ordena. Desse modo, o senhor Severino recorreu a você, pois sabe de suas habilidades com programação. Sua tarefa é simples: ordenar os cadastros dos códigos dos livros.",
        "titulo": "A Biblioteca do Senhor Severino",
        "entrada": "A entrada contém vários casos de teste. Cada teste começa com um valor N (1 ≤ N ≤ 1000). Em seguida, N linhas terão os códigos dos livros, que estão sempre no formato \"xxxx\", isto é, não haverá o cadastro '1', por exemplo, mas \"0001\". A entrada termina com fim de arquivo."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1287",
        "saida": "Para cada caso de teste, seu programa deverá imprimir um inteiro representado pela string n ou \"error\" se n não é um inteiro não-negativo válido. Nota: Uma string vazia não representa um inteiro válido.",
        "descricao": "Computadores estão presentes em uma porcentagem significante de casas pelo mundo e, como programadores, somos responsáveis por criar interfaces que todos possam usar. Interfaces de usuário precisam ser flexíveis de forma que se um usuário comete um erro não fatal, a interface ainda pode deduzir o que o usuário queria dizer. Sua tarefa é escrever um programa que processe um texto de entrada representando um inteiro, porém, como esta é uma interface de usuário, não seremos muito rígidos com o usuário: 1. Se o usuário digita a letra \"O\" ou \"o\", assumimos que ele queria digitar o número \"0\". 2. Se o usuário digita a letra \"l\", assumimos que ele queria digitar o número \"1\". 3. Vírgulas e espaços são permitidos, porém não são processados (são ignorados). Se, mesmo com as regras acima, o usuário não entrou um número não-negativo, imprima a string \"error\". Overflow (um valor maior que 2147483647) é considerado inválido e \"error\" deve ser impresso.",
        "titulo": "Processador Amigável de Inteiros",
        "entrada": "Cada linha da entrada é um caso de teste e contém uma string n. n conterá entre 0 e 50, inclusive, letras, dígitos, espaços ou vírgulas"
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1551",
        "saida": "Para cada caso de teste, imprima uma linha contendo uma das seguintes frases: “frase completa”, quando a frase é considerada completa; “frase quase completa”, quando a frase não é completa, mas é considerada quase completa; ou “frase mal elaborada”, quando ela não é completa e nem quase completa.",
        "descricao": "Seu professor de português não para de trazer coisas novas para a sala, e hoje não foi diferente. Existe uma cidade, segundo seu professor, onde as pessoas levam muito a sério a forma como elas se comunicam. Em especial, quando duas pessoas estão conversando, elas pensam muito nas frases antes de dizê-las, de forma a garantir que tal frase seja uma “frase completa”, ou talvez uma “frase quase completa”. Considerando o nosso alfabeto de 26 letras, uma frase é dita “completa” quando ela contém todas as letras do alfabeto contidas nela. De modo semelhante, uma frase é dita “quase completa” se ela não é completa, porém contém ao menos metade das letras do alfabeto contidas nela. Quando uma frase não é “completa” e nem “quase completa”, ela é dita “mal elaborada”. Seu professor lhe deu uma tarefa muito difícil: dadas várias frases trocadas entre vários habitantes da cidade citada, diga em qual das categorias acima a frase se encaixa.",
        "titulo": "Frase Completa",
        "entrada": "A primeira linha contém um inteiro N, indicando o número de casos de teste a seguir. Cada caso de teste contém uma linha, contendo letras minúsculas, espaços em branco e/ou vírgulas. O número de caracteres de cada linha é no mínimo 3 e no máximo 1000, contando com os espaços."
    },
    {
        "nivel": "5",
        "assunto": "3",
        "numero": "2035",
        "saida": "Para cada caso de teste, você deve imprimir uma única linha contendo um número inteiro, o que representa o número máximo de letras que podem ser impressas em um conjunto de N camisetas válidas para serem utilizadas por ambas as equipes, como explicado na declaração do problema.",
        "descricao": "O Rúgbi da Argentina está atualmente em um de seus melhores momentos de todos os tempos. Recentemente, os menores de 18 anos e as equipes sub-21 nacionais foram qualificados para seus campeonatos mundiais, de modo que os treinadores de ambas as equipes pediram à Incrível Comissão para a Produção de Roupas (ICPR) para fornecer as camisetas para esses eventos. Cada equipe é formada por N jogadores, mas porque as duas Copas do Mundo não ocorrem simultaneamente, a ICPR forneceria apenas N camisetas, para serem usadas por ambas as equipes. Por esta razão, as camisetas deve ser um conjunto válido de roupas para ambas as equipes. As regras das Copas do Mundo de Rúgbi determinam que cada jogador deve ir a campo com uma camiseta que tenha impresso um único número, juntamente com uma abreviação do sobrenome do jogador, não necessariamente único. Isto inclui os casos como camisetas sem abreviação de sobrenome (ou seja, um sobrenome de comprimento 0) e uma camiseta com um sobrenome completo. Os peritos do ICPR imediatamente perceberam que podiam simplesmente fornecer N camisetas com apenas números e sem sobrenomes, e cada uma delas seria uma camiseta válida para ser usado por qualquer jogador. No entanto, os treinadores preferem ter as camisetas com os mais longos sobrenomes possíveis, é claro, sem violar as regras da Copa do Mundo, porque desta forma é mais fácil para eles identificar os jogadores, enquanto os jogos estão ocorrendo. Sua tarefa é ajudar o ICPR encontrar o máximo de letras que podem ser impressas em um conjunto de N camisetas, de modo que este conjunto seja válido para ambas as equipes. Por exemplo, se temos N = 3 jogadores, a equipe sub-18 é composto por \"PEREZ\", \"GONZALEZ\" e \"LOPEZ\", enquanto que a equipe sub-21 é composto por \"GARCIA\", \"PERALTA\" e \"RODRIGUEZ\", a escolha ideal consiste em ter uma camiseta com 1 letra \"G\" (para ser usado por \"GONZALEZ\" e \"GARCIA\"), outra com 3 letras sobrenome \"PER\" (a ser utilizado por \"PEREZ\" e \"PERALTA\"), e a terceira camiseta com 0 letras (sendo utilizadas por \"LOPEZ\" e \"RODRIGUEZ\"). Desta forma, a resposta neste caso seria 1 + 3 + 0 = 4.",
        "titulo": "Projetando Camisetas",
        "entrada": "Cada caso de teste é descrito usando três linhas. A primeira linha contém um número inteiro N, indicando o número de jogadores em cada uma das duas equipes (1 ≤ N ≤ 104). A segunda linha contém os apelidos dos N jogadores na equipe sub-18, e a terceira linha contém os sobrenomes dos N jogadores na equipe sub-21. Cada sobrenome é uma string não vazia de no máximo 100 letras maiúsculas. Em cada caso de teste, o número total de caracteres nos 2N sobrenomes é, no máximo, 105, e dois ou mais jogadores do mesmo ou de diferentes equipes podem ter o mesmo sobrenome. O final da entrada e indicado por uma linha contendo -1."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "1871",
        "saida": "Para cada caso de teste, imprima o resultado da soma dos dois valores, sem os Zeros.",
        "descricao": "Um dia o Prof. Humberto José Roberto fez o seguinte questionamento: Se o zero a esquerda de um número não tem valor algum, por que teria em outras posições de um número? Analisando da seguinte forma, ele pede sua ajuda para, ao somar dois valores inteiros, que o resultado seja exibido segundo o raciocínio dele, ou seja, sem os Zeros. Por exemplo, ao somar 15 + 5, o resultado seria 20, mas com esta nova ideia, o novo resultado seria 2, e, ao somar 99 + 6, o resultado seria 105, mas com esta nova ideia, o novo resultado seria 15. Escreva um programa que, dado dois números inteiros, sem o algarismo zero, some os mesmos e, caso o resultado tenha algum algarismo zero, que os retire antes de exibir.",
        "titulo": "Zero vale Zero",
        "entrada": "Haverá diversos casos de teste. Cada caso de teste inicia com dois inteiros M e N (1 ≤ M ≤ N ≤ 999.999.999). O último caso de teste é indicado quando N = M = 0, sendo que este caso não deve ser processado."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1629",
        "saida": "Para cada linha compactada você deve exibir o dígito verificador descompactado.",
        "descricao": "Em 2013 a Feira FACE compactou os dados de seus visitantes com um compactador livre, infelizmente esta ferramenta se tornou paga e você foi convidado a criar um algoritmo para descompactar os dados. Os dados estão compactados em formato decimal, e para funcionar o descompactador você terá que encontrar o dígito verificador de cada linha compactada. A organização da FACE conseguiu uma documentação de como funcionava o processo, mas algumas informações de como chegar ao dígito não estão muito claras, o documento apenas disponibiliza alguns exemplos, conforme segue: Linha compactada composta por 54782 ao descompactar iria resultar na cadeia binária 00000111100000001111111100, com isso o valor do dígito ficaria 8. Linha compactada composta por 045 ao descompactar iria resultar na cadeia binária 111100000, com isso o valor do dígito ficaria 9.",
        "titulo": "DescompactaFACE",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de um caso de teste contém um inteiro N (1 ≤ N ≤ 25), representando o número de dados dos visitantes daquele arquivo, sendo que cada linha representa um visitante. As N linhas seguintes são compostas por K dígitos (1 ≤ K ≤ 103) sem espaço representando a linha compactada. A parada é determinada por N igual a 0."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1222",
        "saida": "Para cada caso de teste imprima uma única linha, contendo um único número inteiro, indicando o número mínimo de páginas que o conto de Machado ocupa, considerando as regras do concurso.",
        "descricao": "Machado gosta muito de escrever. Já escreveu muitos contos, resenhas, relatos de viagens que fez, além de um pequeno romance. Agora Machado quer participar de um concurso de contos, que tem regras muito rígidas sobre o formato de submissão do conto. As regras do concurso especificam o número máximo de caracteres por linha, o número máximo de linhas por página, além de limitar o número total de páginas. Adicionalmente, cada palavra deve ser escrita integralmente em uma linha (ou seja, a palavra não pode ser separada silabicamente em duas linhas). Machado quer escrever um conto com o maior número de palavras possível, dentro das regras do concurso, e precisa de sua ajuda. Dados o número máximo de caracteres por linha, o número máximo de linhas por página, e as palavras do conto que Machado está escrevendo, ele quer saber o número mínimo de páginas que seu conto utilizaria seguindo as regras do concurso.",
        "titulo": "Concurso de Contos",
        "entrada": "A primeira linha de um caso de teste contém três inteiros N (2 ≤ N ≤ 1000), L (1 ≤ L ≤ 30 ) e C (1 ≤ C ≤ 70) , que indicam, respectivamente, o número de palavras do conto de Machado, o número máximo de linhas por página e o número máximo de caracteres por linha. O conto de Machado é inovador e não contém nenhum caractere além de letras maiúsculas e minúsculas e espaços em branco, sem letras acentuadas e sem cedilha. A segunda linha contém o conto de Machado, composto de N palavras (1 ≤ comprimento de cada palavra ≤ C) separadas por espaços em branco; há espaço em branco somente entre duas palavras, e entre duas palavras há exatamente um espaço em branco. O final da entrada é determinado pelo final de arquivo (EOF)."
    },
    {
        "nivel": "6",
        "assunto": "3",
        "numero": "1842",
        "saida": "Imprima uma linha composta unicamente da maior subcadeia de S com no mínimo 3 caracteres que se repete em S no mínimo uma vez. Se há mais de uma subcadeia que se repete com comprimento máximo, imprima a primeira delas em ordem lexicográfica, lembrando que o caractere ‘-’ aparece antes na tabela ASCII que o caractere ‘.’. Se não há subcadeias de S com comprimento no mínimo 3 que se repetem, a linha de saída deve ser composta unicamente do caractere ‘*’.",
        "descricao": "Dentre as mais importantes rodovias que cruzam o estado de Santa Catarina estão a BR282, que o cruza de leste a oeste, e a BR153, que cruza praticamente o Brasil inteiro de norte a sul. O encontro entre essas duas rodovias é conhecido popularmente como Trevo de Irani, porque ocorre na cidade de Irani, ou Trevo da Fênix, porque sua forma, vista de cima, lembra a criatura mítica fênix, conforme mostra a Figura. A região do estado em que fica o Trevo da Fênix é chamada de Vale do Contestado, porque foi palco de uma das mais importantes guerras civis da história do Brasil: a Guerra do Contestado (1912–1916), entre rebeldes da população cabocla, sob a liderança notória do monge José Maria dentre outras, e tropas federais do Exército Brasileiro, sob a liderança notória do Cel. João Gualberto dentre outras. Conta-se que, certa vez, um grupo de rebeldes fugia desesperado das tropas do Exército e veio parar no Trevo da Fênix. Frustrado com a batalha que haviam perdido no dia, um deles chutou o pó da terra. O vento levantou o pó, o qual, na verdade, não era pó, mas cinzas, e por um momento os caboclos viram uma fênix, que lhes deu uma Ordem: “Morse!”. Tendo regressado ao acampamento no dia seguinte e contado a história ao monge José Maria, os caboclos passaram a estudar o Código Morse, a interceptar mensagens das tropas do Cel. João Gualberto e a tentar identificar padrões repetidos nessas mensagens.",
        "titulo": "A Ordem da Fênix",
        "entrada": "A entrada é composta por uma cadeia S de no mínimo 1 e no máximo 105 caracteres, finalizada por uma quebra de linha, a qual representa uma mensagem interceptada. Além da quebra de linha, apenas os caracteres ‘.’ (ponto) e ‘-’ (traço) compõem a entrada."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1737",
        "saida": "Para cada caso de teste gere 5 linhas contendo os top 5 dígrafos juntamente com suas frequências absolutas e relativas. Imprima o último arredondado com uma precisão de seis casas decimais. Se dois dígrafos tiverem a mesma frequência, ordene-os em (ASCII) ordem lexicográfica. Imprima uma linha em branco após cada caso de teste.",
        "descricao": "A frequência relativa de caracteres em textos de linguagem natural é muito importante para a criptografia. No entanto, as estatísticas variam para diferentes idiomas. Aqui estão os top 9 caracteres ordenados por suas frequências relativas para várias línguas comuns: Inglês: ETAOINSHR Alemão: ENIRSATUD Francês: EAISTNRUL Espanhol: EAOSNRILD Italiano: EAIONLRTS Finlandês: AITNESLOK Tão importante quanto as frequências relativas de caracteres simples são os de pares de caracteres, os chamados dígrafos. Dado vários exemplos de texto, calcule os dígrafos com as melhores frequências relativas.",
        "titulo": "Etaoin Shrdlu",
        "entrada": "A entrada contém vários casos de teste. Cada um começa com um número n em uma linha separada, indicando o número de linhas do caso de teste. A entrada é terminada por n = 0. Caso contrário, 1 ≤ n ≤ 64, e seguem n linhas, cada uma com um comprimento máximo de 80 caracteres. A concatenação dessas n linhas, onde os caracteres de fim de linha (end-of-line) são omitidos, dá o exemplo de texto que você tem que analisar. O texto irá conter apenas caracteres ASCII imprimíveis."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1257",
        "saida": "Para cada caso de teste imprima o valor de hash que é calculado conforme o exemplo apresentado acima.",
        "descricao": "Você terá como uma entrada várias linhas, cada uma com uma string. O valor de cada caracter é computado como segue: Valor = (Posição no alfabeto) + (Elemento de entrada) + (Posição do elemento) Todas posições são baseadas em zero. 'A' tem posição 0 no alfabeto, 'B' tem posição 1 no alfabeto, ... O cálculo de hash retornado é a soma de todos os caracteres da entrada. Por exemplo, se a entrada for: CBA DDD então cada caractere deverá ser computado como segue: 2 = 2 + 0 + 0 : 'C' no elemento 0 posição 0 2 = 1 + 0 + 1 : 'B' no elemento 0 posição 1 2 = 0 + 0 + 2 : 'A' no elemento 0 posição 2 4 = 3 + 1 + 0 : 'D' no elemento 1 posição 0 5 = 3 + 1 + 1 : 'D' no elemento 1 posição 1 6 = 3 + 1 + 2 : 'D' no elemento 1 posição 2 O cálculo final de hash será 2+2+2+4+5+6 = 21.",
        "titulo": "Array Hash",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste. Cada caso de teste inicia com um inteiro L (1 ≤ L ≤ 100) que indica a quantidade de linhas que vem a seguir. Cada uma destas L linhas contém uma string com até 50 letras maiúsculas ('A' - 'Z')."
    },
    {
        "nivel": "5",
        "assunto": "3",
        "numero": "2017",
        "saida": "Imprima o índice da string mais próxima da primeira linha. Se este valor for diferente de -1, imprima o valor de distância de edição da segunda linha.",
        "descricao": "O problema é simples. Dada uma string x e 5 outras strings, encontre a string com o menor valor de distância de edição com relação a x. Se o valor da distância de edição for maior do que k, imprima -1.",
        "titulo": "Seis Strings",
        "entrada": "A primeira linha contém uma string x ( 1 ≤ len(x) ). A próxima linha contém um inteiro k ( 1 ≤ k ≤ 100 ). Cada uma das próximas 5 linhas contém uma string y ( len(y) ≤ 100000)."
    },
    {
        "nivel": "7",
        "assunto": "3",
        "numero": "2093",
        "saida": "Imprima uma linha contendo um inteiro representando o comprimento mínimo de um separador aceitável para um dado registo.",
        "descricao": "Um protocolo de comunicação é um conjunto de regras para a transmissão de informações de um sistema de comunicações. O trabalho de Elisa é escrever programas para implementar partes de tais protocolos. Muitas vezes é necessário, para transmitir sequências de campos, saber onde um campo termina e outro começa, onde um separador é inserido entre cada par de campos consecutivos. Usar um separador simples, como um espaço, vírgula, ou ponto e vírgula, tem a desvantagem de que, algumas vezes, os campos a serem transferidos podem conter esses mesmos caracteres. A solução padrão para esses casos é inserir um caractere \"escaping\" logo antes de cada separador dentro de um campo, para distingui-lo de um separador real. Elisa acredita que esta solução irá aumentar muito o comprimento dos dados a serem transmitidos, então ela decidiu usar um separador complexo o suficiente para nunca aparecer nos dados. Dessa forma ela espera fugir da alternativa ineficiente de pular os separadores. Para escolher o separador ideal, Elisa compilou um registo, que nada mais é que uma longa sequência de caracteres que representam os dados que o seu protocolo precisa controlar. Após pensar sobre o problema por um tempo, Elisa concluiu que qualquer sequencia não vazia de caracteres que não aparece dentro do registo poderia ser um separador aceitável para usar dentro de seu protocolo. Mas, uma vez que ela está interessada em minimizar o comprimento dos dados a transmitir, queria saber o tamanho mínimo que um separador aceitável pode ter. Ela começou imediatamente a escrever um programa para calcular tal comprimento, e agora está testando-o para um caso especial, em que o registo e os separadores aceitáveis contém apenas dígitos binários (‘0’ ou ‘1’). Você pode antecipar os resultados?",
        "titulo": "Fuja para Escapar",
        "entrada": "Uma única linha contendo um registo, que é uma string não-vazia de no máximo 105 dígitos binários."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1332",
        "saida": "Para cada caso de teste, imprima o valor numérico da palavra.",
        "descricao": "Seu irmão mais novo aprendeu a escrever apenas um, dois e três, em Inglês. Ele escreveu muitas dessas palavras em um papel e a sua tarefa é reconhecê-las. Nota-se que o seu irmão mais novo é apenas uma criança, então ele pode fazer pequenos erros: para cada palavra, pode haver, no máximo, uma letra errada. O comprimento de palavra é sempre correto. É garantido que cada palavra que ele escreveu é em letras minúsculas, e cada palavra que ele escreveu tem uma interpretação única.",
        "titulo": "Um-Dois-Três",
        "entrada": "A primeira linha contém o número de palavras que o seu irmão mais novo escreveu. Cada uma das linhas seguintes contém uma única palavra com todas as letras em minúsculo. As palavras satisfazem as restrições acima: no máximo uma letra poderia estar errada, mas o comprimento da palavra está sempre correto. Haverá, no máximo, 1000 palavras de entrada."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1458",
        "saida": "Para cada caso de teste imprima uma linha contendo o tempo, em segundos, que nosso competidor ideal levaria para digitar a mensagem dada. Utilize duas casas decimais para exibir a resposta.",
        "descricao": "A Só Birutas Celulares, uma renomada empresa do ramo de telefonia móvel, promove um campeonato de mensagens de texto todos os anos. Neste campeonato, ganha quem digitar uma dada mensagem mais rápido. O aparelho oficial da competicão, de uso obrigatório, tem um teclado muito simples, similar ao celular que você provavelmente teria no bolso se aparelhos eletrônicos não fossem proibidos durante a Maratona de Programacão. O teclado tem o seguinte layout: ​ Como só é permitido o uso dos polegares para pressionar as teclas, todas elas foram feitas quadradas, com 1 centímetro de lado, sem espaço entre duas teclas adjacentes. As teclas de 2 a 9 são usadas para digitar as letras de 'a' a 'z', e funcionam como em qualquer celular: se quisermos obter uma das letras associadas a uma das teclas, precisamos pressioná-la um número de vezes igual à posição da letra desejada. Por exemplo, pressionando a tecla 3 uma vez obtemos 'd'. Se pressionarmos novamente, obteremos 'e' e depois 'f'. Se continuarmos pressionando-a obteremos o número '3' e depois reiniciamos em 'd'. A tecla 0 é utilizada para inserir espaços na mensagem; as teclas 1 e * não são utilizadas nesta competição. No caso de termos duas letras consecutivas na mensagem que são formadas pela mesma tecla será necessário fazer uso da tecla #. A função desta tecla é separar as sequências de pressionamentos de duas letras na mesma tecla. Por exemplo, para digitar a palavra \"casa\", a sequência de teclas pressionadas seria a seguinte: 2, 2, 2, #, 2, 7, 7, 7, 7, 2. Para tornar as coisas mais interessantes, a organizaçãao decidiu que este ano as mensagens devem ser digitadas em queda livre: os competidores pulam de um avião com o celular em mãos e digitam a mensagem; um sofisticado sistema computadorizado abrirá o paraquedas automaticamente quando a mensagem tiver sido digitada sem erros. Entretanto, essa modificação das regras introduziu uma dificuldade a mais: para evitar que o celular se perca durante a queda, é necessário utilizar um polegar para segurar o aparelho enquanto o outro pressiona uma tecla ou é movido; ou seja, um dos polegares está sempre fixo. Para satisfazer a curiosidade da platéia, você foi contratado para fazer um programa de computador que, dada uma mensagem de até 140 caracteres, responde o tempo mínimo necessário para um competidor ideal digitá-la no celular. Suponha que um competidor ideal consegue mover seus polegares à incrível velocidade de 30 centímetros por segundo, leva apenas 2 décimos de segundo para pressionar uma tecla, inicia a queda livre com o polegar esquerdo sobre a tecla 4, o polegar direito sobre a tecla 6 e sempre pressiona as teclas perfeitamente em seus centros.",
        "titulo": "Campeonato de SMS",
        "entrada": "A entrada contém diversos casos de teste. Cada caso de teste é composto por uma mensagem, que é uma string que contém de 1 a 140 caracteres ('a'-'z' ou ' '), inclusive. Nenhuma mensagem começa ou termina com espaços e tampouco contém acentos ou dois espaços consecutivos. O final da entrada é indicado por final de arquivo (EOF)."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1406",
        "saida": "Para cada caso de teste seu programa deve produzir uma linha simples com a soma mínima dos tamanhos das strings de ouro. Você pode assumir que sempre existirá uma solução.",
        "descricao": "Os juízes ICPC estão preparando um festa para a cerimônia de abertura. Para a festa, eles pretendem adicionar um playlist com algumas músicas para o software jukebox (um simples MP3 player). Entretanto, existem muitas músicas no computador, isso dificulta encontrar aquelas que eles querem adicionar. Como consequência, eles precisam usar algumas buscas muitas vezes. Nesta jukebox, quando você pesquisa por uma string s, o software retorna todas músicas cujos títulos ou nomes de artistas contém s como uma substring. A string s é uma substring da string t se t contém todos os caracteres de s como uma sequência contígua (por exemplo, 'bc' é uma substring de 'abcd', mas 'ac' não é). Para salvar o tempo precioso deles, enquanto procuram por uma música, eles sempre usam uma string de ouro da música, isto é, uma das mais curtas strings que retornam de uma pesquisa como resultado somente a música que eles querem. Neste exemplo, uma possível string de ouro para a música 'johnnatan' é 'ta'. Note que 'ta' não é uma substring do nome de outra música nem é uma substring do nome do artista de outra música. Note também que não existem strings de tamanho igual a 1 que podem identificar unicamente a música 'johnnatan'. ​ Eles descobriram que se eles removem o campo artista de algumas músicas eles podem obter strings de ouro menores. Para a música 'john', não existe nenhuma string de ouro. Entretanto, se removermos o campo artista de todas as outras músicas, a string 'c' se torna a string de ouro para a música 'john'. Dada uma lista de músicas (cada música com nome e artista), sua tarefa é determinar a soma mínima do tamanho das strings de ouro para todas as músicas que podem ser obtidas se em algumas removermos o campo artista. Na figura acima, você pode ver um possível melhor resultado com as strings de ouro em negrito. A soma mínima dos tamanhos das strings de ouro neste caso é 10.",
        "titulo": "Jukebox",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de cada caso de teste contém um inteiro N (1 ≤ N ≤ 30), que indica o número de músicas. A seguir, existirão N pares de linhas (2*N linhas), um par para cada música. A primeira linha de um par contém o nome da música, a segunda conterá o nome da artista. Ambos, nome de artista e música, são strings contendo somente letras minúsculas e sobrescritos e terão no mínimo 1 e no máximo 30 caracteres. Existirão no máximo 6 artistas diferentes na lista. O fim da entrada é dado por N = 0."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1530",
        "saida": "Para cada instrução do tipo 2, imprima uma linha contendo o número de substrings diferentes que a string possui.",
        "descricao": "Iniciamente, há uma string vazia. Seu programa deve realizar dois tipos de instruções: Adicionar um caractere entre 'a' e 'z' ao final da string. Calcular quantas substrings diferentes a string possui. Por exemplo, a string \"aba\" possui 5 substrings diferentes: \"a\", \"ab\", \"aba\", \"b\", \"ba\".",
        "titulo": "Quantas Substrings?",
        "entrada": "A entrada é composta por vários casos de teste. Cada caso de teste consiste de uma linha contendo uma sequência com até 2.105 caracteres. Cada caractere representa uma instrução que deve ser feita. Um caractere entre 'a' e 'z' indica que deve ser realizado uma instrução do tipo 1 com esse caractere. Um caractere '?' representa uma instrução do tipo 2."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1241",
        "saida": "Para cada caso de entrada imprima uma mensagem indicando se o segundo valor encaixa no primeiro valor, confome exemplo abaixo.",
        "descricao": "Paulinho tem em suas mãos um novo problema. Agora a sua professora lhe pediu que construísse um programa para verificar, à partir de dois valores muito grandes A e B, se B corresponde aos últimos dígitos de A.",
        "titulo": "Encaixa ou Não II",
        "entrada": "A entrada consiste de vários casos de teste. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste. Cada caso de teste consiste de dois valores A e B maiores que zero, cada um deles podendo ter até 1000 dígitos."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1243",
        "saida": "Compute o comprimento médio das palavras do enunciado do problema, e mostre a classificação do problema, para mais detalhes olhe o exemplo abaixo.",
        "descricao": "TopCoder decidiu automatizar o processo de atribuição de níveis de dificuldade para os problemas. Os desenvolvedores do TopCoder concluíram que a dificuldade do problema esta relacionado apenas ao comprimento médio das palavras do enunciado do problema. Se o comprimento médio das palavras do enunciado é menor ou igual a 3, o problema recebe dificuldade de 250 pontos. Se o comprimento médio das palavras do enunciado for 4 ou 5, o problema recebe dificuldade de 500 pontos. Se o comprimento médio das palavras do enunciado for maior ou igual a 6, o problema recebe dificuldade de 1000 pontos. Definições: Símbolo: um conjunto de carateres ligados em ambos os lados por espaços, ou pelo início da descrição do problema, ou ainda pelo fim da descrição do problema. Palavra: um símbolo que contenha apenas letras a-z ou A-Z, e pode terminar com um único ponto. Comprimento da palavra: número de letras de uma palavra (um ponto não é uma letra). Exemplos de símbolos que são palavras (aspas duplas apenas para exemplificar): \"AB\", \"ab\". Exemplo de símbolos que não são palavras: \"ab..\", \"a.b\", \".ab\", \"a.b.\", \"a2b.\", \".\". O comprimento médio das palavras é dado pela soma dos tamanhos das palavras do enunciado dividido pelo numero de palavras, a divisão é feita por números inteiros. Se o número de palavras for zero, então o comprimento médio das palavras é zero. Sua tarefa é dado o enunciado do problema, computar a sua classificação de dificuldade do problema, que poderá ser 250, 500, ou 1000.",
        "titulo": "O Quão Fácil é...",
        "entrada": "A entrada contém vários casos de teste. Cada caso de teste é composto por uma linha que contém o enunciado de um problema, é uma string que contém entre 1 e 50 caracteres ('A'-'Z', 'a'-'z', '0'-'9', ' ', '.'), inclusive. O final da entrada é determinado por EOF."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1273",
        "saida": "Para cada caso de teste imprima as palavras inserindo tantos espaços quanto forem necessários à esquerda de cada palavra, para que elas apareçam todas alinhadas à direita e na mesma ordem da entrada. Deixe uma linha em branco entre os casos de teste. Não deixe espaços sobrando no final de cada linha nem imprima espaços desnecessários à esquerda, de modo que pelo menos uma das linhas impressa em cada texto inicie com uma letra.",
        "descricao": "Nós temos algumas palavras e queremos justificá-las à direita, ou seja, alinhar todas elas à direita. Crie um programa que, após ler várias palavras, reimprima estas palavras com suas linhas justificadas à direita.",
        "titulo": "Justificador",
        "entrada": "A entrada contém diversos casos de testes. A primeira linha de cada caso de teste conterá um inteiro N (1 ≤ N ≤ 50), que indicará o número de palavras que virão a seguir. Cada uma das N palavras contém no mínimo uma letra e no máximo 50 letras maiúsculas (‘A’-‘Z’). O fim da entrada é indicado por N = 0."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "1168",
        "saida": "Para cada caso de teste, imprima uma linha contendo o número de leds que João precisa para montar o valor desejado, seguido da palavra \"leds\".",
        "descricao": "João quer montar um painel de leds contendo diversos números. Ele não possui muitos leds, e não tem certeza se conseguirá montar o número desejado. Considerando a configuração dos leds dos números abaixo, faça um algoritmo que ajude João a descobrir a quantidade de leds necessário para montar o valor.",
        "titulo": "LED",
        "entrada": "A entrada contém um inteiro N, (1 ≤ N ≤ 1000) correspondente ao número de casos de teste, seguido de N linhas, cada linha contendo um número (1 ≤ V ≤ 10100) correspondente ao valor que João quer montar com os leds."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1898",
        "saida": "Imprima o CPF do corrupto, conforme apresentado abaixo e soma dos valores que foram desviados dos cofres públicos, sempre com duas casas decimais.",
        "descricao": "A agência gaúcha para investigações criminais denominada OBI (Operação de Baita Investigação) notou que, a exemplo do que ocorreu na Petrobrás, muito dinheiro foi desviado dos cofres públicos do estado para pagamento de propina a políticos nos últimos anos, especialmente pelo partido QU (Quadrilha Unida). A investigação está em andamento e a agência recrutou você para converter alguns valores que ficaram com caracteres estranhos após terem sidos descriptografados dos arquivos originais. Sua tarefa neste caso é relativamente simples: basta retirar todos os caracteres estranhos (não numéricos) de cada um dos dois valores disponíveis e somar estes valores. Apenas tome o cuidado de separar da soma os primeiros 11 dígitos do primeiro valor. Eles correspondem ao CPF do corrupto :)",
        "titulo": "Soma de Propina",
        "entrada": "A entrada é composta por duas linhas, cada uma delas contendo entre 1 e 60 caracteres ('0'-'9' e outros caracteres não numéricos ou, pelo menos, 1 caracter '0'-'9') e no máximo um ponto \".\". Desconsiderando os caracteres não numéricos, o número final não deve ter mais de 17 caracteres (incluindo o ponto decimal). Qualquer número após a segunda casa decimal deve ser descartado."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1276",
        "saida": "Para cada caso de teste de entrada, seu programa deverá imprimir as faixas de letras ordenadas alfabeticamente pelo menor valor de cada faixa. Faixas de letras a serem impressas devem representar a maior sequencia possível de letras de entrada em ordem crescente. Ignore espaços e letras duplicadas contidas na entrada. Se a string for vazia, apenas imprima uma nova linha. Por exemplo, a string \"fb xee ac\" tem três faixas de letras, \"a:c\" (as letras 'a', 'b' e 'c'), \"e:f\" (as letras 'e' e 'f') e \"x:x\" (a letra 'x'). Por favor, recorra aos exemplos.",
        "descricao": "Uma faixa de letras é um conjunto de letras minúsculas alfabeticamente consecutivas tomadas de 'a' até 'z'. A menor e maior letras da faixa, separadas por dois pontos (o caractere ':'), são usadas para representar a faixa de letras. Por exemplo, a faixa \"a:c\" representa as letras consecutivas 'a', 'b' e 'c'. (as aspas não fazem parte da faixa). A faixa \"w:z\" representa as letras 'w', 'x', 'y' e 'z'. A faixa \"m:m\" representa apenas a letra 'm'.",
        "titulo": "Faixa de Letras",
        "entrada": "Cada linha de entrada é um caso de teste. Cada caso de teste contém uma string, que pode ser vazia e cujas letras podem não estar em ordem alfabética, de letras minúsculas (a-z) e espaços. A string conterá entre 0 e 50 caracteres, inclusive."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1248",
        "saida": "Para cada caso de teste imprima uma string que representa os alimentos que você deveria consumir no jantar, ou \"CHEATER\" caso você tenha trapaceado na sua dieta.",
        "descricao": "O doutor deu a você a sua dieta, na qual cada caractere corresponde a algum alimento que você deveria comer. Você também sabe o que você tem comido no café da manha e no almoço, nos quais cada caractere corresponde a um tipo de alimento que você deveria ter comido aquele dia. Você decidiu que irá comer todo o restante de sua dieta durante o jantar, e você quer imprimi-la como uma String (ordenada em ordem alfabética). Se você trapaceou de algum modo (ou por comer muito de tipo de alimento, ou por comer algum alimento que não está no plano de dieta), você deveria imprimir a cadeia \"CHEATER\" (significa trapaceiro), sem as aspas.",
        "titulo": "Plano de Dieta",
        "entrada": "A entrada contém vários casos de teste. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste. Cada caso de teste é composto por três linhas, cada uma delas com uma string com até 26 caracteres de 'A'-'Z' ou vazia, representando respectivamente os alimentos da dieta, do café da manhã e do almoço."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1120",
        "saida": "Para cada caso de teste da entrada o seu programa deve imprimir uma linha contendo um único inteiro V, o valor numérico representado de fato no contrato.",
        "descricao": "Durante anos, todos os contratos da Associação de Contratos da Modernolândia (ACM) foram datilografados em uma velha máquina de datilografia. Recentemente Sr. Miranda, um dos contadores da ACM, percebeu que a máquina apresentava falha em um, e apenas um, dos dígitos numéricos. Mais especificamente, o dígito falho, quando datilografado, não é impresso na folha, como se a tecla correspondente não tivesse sido pressionada. Ele percebeu que isso poderia ter alterado os valores numéricos representados nos contratos e, preocupado com a contabilidade, quer saber, a partir dos valores originais negociados nos contratos, que ele mantinha em anotações manuscritas, quais os valores de fato representados nos contratos. Por exemplo, se a máquina apresenta falha no dígito 5, o valor 1500 seria datilografado no contrato como 100, pois o 5 não seria impresso. Note que o Sr. Miranda quer saber o valor numérico representado no contrato, ou seja, nessa mesma máquina, o número 5000 corresponde ao valor numérico 0, e não 000 (como ele de fato aparece impresso).",
        "titulo": "Revisão de Contrato",
        "entrada": "A entrada consiste de diversos casos de teste, cada um em uma linha. Cada linha contém dois inteiros D e N (1 ≤ D ≤ 9, 1 ≤ N < 10100 ), representando, respectivamente, o dígito que está apresentando problema na máquina e o número que foi negociado originalmente no contrato (que podem ser grande, pois Modernolândia tem sido acometida por hiperinflação nas últimas décadas). O ultimo caso de teste é seguido por uma linha que contém apenas dois zeros separados por espaços em branco."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1448",
        "saida": "Para cada instância, você deverá imprimir um identificador Instancia k, onde k é o número da instância atual. Na linha seguinte você deve imprimir qual dos times foi o vencedor ou se houve empate. Após cada instância, seu programa deve imprimir uma linha em branco.",
        "descricao": "Toda criança já brincou de \"telefone sem fio\". Joãozinho inventou uma variação da brincadeira. O grupo de crianças é dividido em dois times. Os times se organizam como na brincadeira original, em que cada um repete o que lhe foi falado para o seguinte, até que o último diz o que chegou até ele. No caso da brincadeira de Joãozinho será falada uma frase com n caracteres (contando letras, espaços, sinais de pontuação, etc). Todos sabem que a frase tem este comprimento. A frase é falada pelo juiz ao primeiro competidor de cada time que a repete para o segundo, e este para o terceiro e assim sucessivamente, até que o último competidor de cada time escreve a frase final (garantindo que n caracteres sejam escritos) e a entrega para o juiz. A equipe vencedora é aquela cuja frase final seja mais próxima da frase original. Para calcular a semelhança entre duas frases de mesmo comprimento você deve contar o número de vezes em que o caractere da frase do time coincide com o caractere da frase original. Ganha o time para o qual o número de coincidências seja máximo. Se os dois times empataram neste critério, a primeira vez que um dos times acertou e o outro errou decide. Exemplo: Se a frase original foi \"O rato roeu a roupa do rei.\", o primeiro time escreveu \"O ator morreu, garoupa rei.\" e o segundo time escreveu \"O pato moeu garoupa dorlei.\" O segundo time ganhou pois teve 21 coincidências contra 9 coincidências do primeiro: Assim como os juízes da Maratona de Programação, estes juízes são muitos preguiçosos. Logo, pediram para você escrever um programa que resolve este problema.",
        "titulo": "Telefone Sem Fio",
        "entrada": "A entrada começa com um inteiro t, onde 1 ≤ t ≤ 1000, indicando o número de instâncias que seu programa deve analisar. Cada instância é composta por três linhas, na primeira a frase correta, na segunda a frase do primeiro time e na terceira a frase do segundo time. Cada frase tem no máximo 100 caracteres, e as frases possuem sempre o mesmo tamanho."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1355",
        "saida": "Para cada caso de teste, imprima o comprimento da String mínima, e uma String comprimida. Note que cada número inteiro de um byte deve ser contado como um caractere, mesmo que tenha dois ou três dígitos na sua forma decimal.",
        "descricao": "Sua tarefa é comprimir uma string de no máximo 200 caracteres, usando o seguinte esquema: - Adjacentes que se repetem: [S]k que significa: S repetido k vezes (onde k é um número inteiro de um byte, lembre-se que o comprimento da String não excede 200). - Repete com lacunas: [S]k{S_1}t_1{S_2}t_2...{S_r}, onde 1 ≤ t_i < k, t_i < t_{i+1} que significa: escrever S para k vezes, em seguida, introduza a String S_i após a t_i ocorrência de S. Note que a compressão é feita de forma recursiva, para S, S_1, ..., S_r mencionado acima, onde tudo pode ser comprimido. Por exemplo: para a string original I_am_WhatWhat_is_WhatWhat O resultado ideal seria: I_am_[What]4{_is_}2",
        "titulo": "Compressor",
        "entrada": "Há, no máximo, 20 casos de teste, cada caso de teste é uma string contendo não mais do que 200 caracteres imprimíveis, sem espaços em branco (ou seja, sem espaços e sem tabulações), colchetes (ou seja, não há {'(', ')', '[','] ',' {','} '}) e nem dígitos. As letras são case-sensitive."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "2062",
        "saida": "Seu programa deverá apresentar o texto que foi distribuído por Mariazinha corrigido, segundo os critérios acima estabelecidos.",
        "descricao": "Mariazinha criou um exercício para as suas irmãs Paula e Marta: ela distribui um texto e pede que ambas corrijam este texto, sabendo que apenas as palavras OBI e URI podem estar escritas de forma errada, e o erro pode estar apenas na última letra. Sua tarefa aqui é automatizar este processo, ou seja, criar um programa que faça a correção dos textos distribuídos pela Mariazinha para que ela possa conferir as correções de suas irmãs sem muito trabalho. Note que se \"OB\" ou \"UR\" forem o início ou parte de uma palavra maior, como por exemplo \"OBOS\" ou \"URAT\"), estas palavras não devem ser alteradas.",
        "titulo": "OBI URI",
        "entrada": "A entrada contém duas linhas. A primeira linha contém um valor inteiro N (1 < N < 10000) que indica a quantidade de palavras do texto. A segunda linha contém as palavras do texto, cada uma com o máximo de 20 caracteres ('A'-'Z'), e com no mínimo, uma letra ('A'-'Z')."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1519",
        "saida": "Para cada caso de teste, imprima uma linha contendo a frase já com as abreviações escolhidas e aplicadas. Em seguida, imprima um inteiro N, indicando o número de palavras em que foram escolhidas uma letra para a abreviação no texto. Nas próximas N linhas, imprima o seguinte padrão “C. = P”, onde C é a letra inicial e P é a palavra escolhida para tal letra. As linhas devem ser impressas em ordem crescente da letra inicial.",
        "descricao": "Blogs são muito populares hoje em dia, e há inclusive ferramentas que te permitem manter o seu blog sem que você pague nada por isso. Rafael resolveu então criar um blog, onde irá arquivar todas as suas experiências diárias de sua vida agitada. Por mais que estas ferramentas sejam gratuitas, há porém um limite de caracteres que se pode escrever por dia, e Rafael está preocupado que essa limitação o irá impedir de contar suas melhores experiências. Decidiu então usar um sistema de abreviação de palavras em seus posts. O sistema de abreviações funciona da seguinte maneira: para cada letra, é possível escolher uma palavra que inicia com tal letra e que aparece no post. Uma vez escolhida a palavra, sempre que ela aparecer no post, ela será substituída por sua letra inicial e um ponto, diminuindo assim o número de caracteres impressos na tela. Por exemplo, na frase: “hoje eu visitei meus pais”, podemos escolher a palavra “visitei” para representar a letra 'v', e a frase ficará assim: “hoje eu v. meus pais”, economizando assim cinco caracteres. Uma mesma palavra pode aparecer mais de uma vez no texto, e será abreviada todas as vezes. Note que, se após uma abreviação o número de caracteres não diminuir, ela não deve ser usada, tal como no caso da palavra “eu” acima. Rafael precisa que seu post tenha o menor número de caracteres possíveis, e por isso pediu a sua ajuda. Para cada letra escolha uma palavra, de modo que ao serem aplicadas todas as abreviações, o texto contenha o menor número de caracteres possíveis.",
        "titulo": "Abreviações",
        "entrada": "Haverá diversos casos de teste. Cada caso de teste é composto de uma linha, contendo uma frase de até 10⁴ caracteres. A frase é composta de palavras e espaços em branco, e cada palavra é composta de letras minúsculas ('a'-'z'), e contém entre 1 e 30 caracteres cada. O último caso de teste é indicado quando a linha dada conter apenas um “.”, o qual não deverá ser processado."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "1632",
        "saida": "Para cada caso de teste imprima uma linha contendo um inteiro, indicando o número de diferentes variações que é possível montar com a senha dada, incluindo ela mesma.",
        "descricao": "A internet já não é tão segura quanto ela já foi. Um dos sinais disso é o aumento de ataque de hackers a diversos sites. Para piorar, quando um hacker rouba a senha de um usuário em um determinado site, ele tem também acesso a todas as outras contas deste usuário em outros sites, pois a maioria dos usuários hoje em dia usa a mesma senha em todos os sites que acessa. Uma das soluções propostas para resolver este problema é usar diferentes senhas para cada site, ou até mesmo diferentes variações da mesma senha. Por exemplo, para variar a senha “batata”, é possível usar a senha “bAtaTa”, “B4tat4”, “baTATA”, etc. Ou seja, para cada caractere do alfabeto, é possível formar uma variação colocando tal caractere em maiúsculo ou minúsculo. Inclusive, para aumentar o número total de variações, para os caracteres A, E, I, O e S é possível usar também os números 4, 3, 1, 0 e 5, respectivamente. Seu amigo precisa aumentar o número de variações de sua senha, e pediu sua ajuda. Dada a senha que ele escolheu, diga o número de diferentes variações que é possível montar.",
        "titulo": "Variações",
        "entrada": "A primeira linha contém um inteiro T, indicando o número de casos de teste a seguir. Cada caso de teste contém uma sequência de caracteres S, indicando a senha de seu amigo. Para cada senha, haverá no mínimo 1 e no máximo 16 caracteres, os quais podem ser uma das 26 letras do alfabeto, minúsculas ou maiúsculas."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1313",
        "saida": "Para cada caso de teste imprima uma linha contendo um inteiro representando o número de diferentes palavras que podem ser construídas concatenando-se um prefixo não-vazio de uma palavra no primeiro conjunto (palavras em Português) e um sufixo não-vazio de uma palavra no segundo conjunto (palavras em Espanhol).",
        "descricao": "Portuñol é um idioma especial que foi naturalmente desenvolvido na América Latina. Como quase metade da América Latina fala Português e quase metade fala Espanhol (Español), a mistura de ambos os idiomas é natural. Cada palavra em Portuñol é construída tomando um prefixo não-vazio de um palavra em Português e um sufixo não-vazio de uma palavra em Espanhol, e concatenando-os. Um prefixo de uma palavra é qualquer palavra que possa ser obtida apagando zero ou mais caracteres da sua extremidade direita. Um sufixo de uma palavra é qualquer palavra que possa ser obtida apagando zero ou mais caracteres da sua extremidade esquerda. O nome do prórpio idioma tem origem tomando um prefixo da palavra \"Português\" (Portu) e um sufixo da palavra \"Español\" (ñol), e concatenando-os. É claro, que nem toda maneira possível de combinar duas palavras resultará em algo que faz sentido, ou nem mesmo pronunciável, mas isso não é importante. Nós queremos que você escreva um programa para contar o número de diferentes palavras em Portuñol. Será dado a você dois conjuntos não-vazios de palavras para testar o seu programa. O primeiro conjunto representará as palavras em Português e o segundo conjunto representará as palavras em Espanhol. Você precisa calcular o número de palavras diferentes em Portuñol que podem ser construídas usando as regras de prefixo e sufixo descritas acima. Note que a mesma palavra pode ser construída de várias maneiras, mas ela precisa ser contada apenas como uma. Também note que os conjuntos de entrada são apenas para testar o seu programa, então eles não precisam necessariamente ser feitos de palavras atuais do Português ou do Espanhol.",
        "titulo": "Dicionário Portuñol",
        "entrada": "Cada caso de teste é descrito usando várias linhas. A primeira linha contém dois inteiros P e S representando respectivamente o número de palavras em Português e o número de palavras em Espanhol. (1 ≤ P, S ≤ 1000). Cada uma das próximas P linhas contém uma palavra em Português, e cada uma das próximas S linhas contém uma palavra em Espanhol. Cada palavra é uma cadeia não-vazia de no máximo 1000 caracteres. Cada caracteres é uma das 26 letras minúsculas (de 'a' até 'z'). Você pode assumir que dentro de cada caso de teste duas palavras em Português não são iguais, e que a soma dos comprimentos de todas as palavras em Português é no máximo 105. O mesmo se aplica às palavras em Espanhol. O último caso de teste é seguido por uma linha contendo dois zeros."
    },
    {
        "nivel": "2",
        "assunto": "3",
        "numero": "1272",
        "saida": "Para cada caso de teste imprima a mensagem oculta no texto de entrada.",
        "descricao": "Textos podem conter mensagens ocultas. Neste problema a mensagem oculta em um texto é composto pelas primeiras letras de cada palavra do texto, na ordem em que aparecem. É dado um texto composto apenas por letras minúsculas ou espaços. Pode haver mais de um espaço entre as palavras. O texto pode iniciar ou terminar em espaços, ou mesmo conter somente espaços.",
        "titulo": "Mensagem Oculta",
        "entrada": "A entrada contém vários casos de testes. A primeira linha de entrada contém um inteiro N que indica a quantidade de casos de teste que vem a seguir. Cada caso de teste consiste de uma única linha contendo de um a 50 caracteres, formado por letras minúsculas (‘a’-‘z’) ou espaços (‘ ’). Atenção para possíveis espaços no início ou no final do texto! Nota: No exemplo de entrada os espaços foram substituídos por pequenos pontos (‘·’) para facilitar o entendimento dos exemplos."
    },
    {
        "nivel": "4",
        "assunto": "3",
        "numero": "2108",
        "saida": "Para cada caso de teste, exiba o número de caracteres de cada palavra que compõe a frase recebida. Separe a quantidade de caracteres de cada palavra por um ' - '. Exiba também a palavra com a maior quantidade de caracteres de todas as frases recebidas. Obs: Se possuir palavras com números identicos de caracteres, cosiderar a última recebida.",
        "descricao": "Matheus estava conversando com a sua noiva via mensagem de texto, quando ela lhe enviou a seguinte mensagem: 1-4-3 Ele não entendeu a mensagem, então ele perguntou o que isso significava, e ela respondeu que era 'I Love You\" e logo ele percebeu que cada número separado por um ' - ' é a quantidade de caracteres de cada uma das palavras que compõem a frase. Com isso, ele teve a ideia de criar um programa que inserindo determinada frase, ele calcula a quantidade de caracteres de cada uma das palavras e separa os valores por ' - '. Mas ele ainda teve a ideia de que o programa deveria receber várias frases linha por linha e ainda no final da execução do programa, a palavra com a maior quantidade de letras deveria ser exibida.",
        "titulo": "Contando Caracters",
        "entrada": "A entrada consiste de vários casos de teste. A primeira linha de um caso de teste contém uma 1 ≤ String ≤ 100 com uma única palavra ou um conjunto de palavras que formam uma frase. Os casos de teste serão processados quando o número 0 for recebido. Não pode haver mais que um espaço separando cada palavra."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "1868",
        "saida": "Para cada caso de teste imprima N x N tabelas, cada uma separada com um ‘@’, seguindo as regras da animação como descritas anteriormente.",
        "descricao": "A empresa Animações Livres de Falhas, ou ALF, realiza as mais diversas animações usando apenas caracteres na tela. Um dia, foram desafiados a fazer uma animação de uma Espiral Quadrada. Esta deverá proceder da seguinte forma: *Sempre exibirá uma tabela quadrada, com N linhas e N colunas, com um caractere em seu respectivo lugar, sem espaços entre os mesmos; *Esta quantidade N será sempre ímpar; *O primeiro quadro desta animação será com um caractere ‘X’ no centro da tabela e o restante da mesma ocupado com caracteres ‘O’; *Nos quadros seguintes, o caractere ‘X’ será deslocado para os outros locais da tabela, substituindo onde o mesmo estava com ‘O’, exibindo sempre uma vez o ‘X’ em cada quadro. O deslocamento será no formato de uma espiral quadrada, realizando o deslocamento para direita, para cima, para esquerda e para baixo. Veja um exemplo de todos os quadros da animação com N = 5: Escreva um programa que, dado um número inteiro, imprima todos os quadros da animação da espiral quadrada.",
        "titulo": "Espiral Quadrada",
        "entrada": "Haverá diversos casos de teste. Cada caso de teste inicia com um inteiro N (1 ≤ N ≤ 25), indicando o tamanho da tela. O último caso de teste é indicado quando N = 0, sendo que este caso não deverá ser processado."
    },
    {
        "nivel": "1",
        "assunto": "3",
        "numero": "2023",
        "saida": "A saída é dada em uma linha. O nome da criança que fica na última posição da lista deve ser mostrado. Mostre o nome exatamente como foi lido na entrada. Use a ordem alfabética dos nomes para ordenar, mas considere maiúsculas e minúsculas como iguais.",
        "descricao": "Papai Noel classifica todas as crianças do mundo em duas listas: uma das boazinhas e outra das malcriadas. Ele gostaria de saber qual das crianças do mundo é a última da lista de boazinhas, se usar a ordem alfabética. Para isso, ele pediu a todos seus elfos ajudantes que escrevessem os nomes das crianças boas em uma folha. Entretanto, cada elfo escreveu os nomes de um jeito: maiúscula no início e minúsculas depois, todas maiúsculas, todas minúsculas, e todo tipo de combinação entre maiúsculas e minúsculas. Papai Noel quer sua ajuda para, dada a lista de nome das crianças boas, dizer qual delas é a última.",
        "titulo": "A Última Criança Boa",
        "entrada": "A entrada possui várias linhas. Em cada linha há o nome de uma criança boa. Nenhum elfo escreveu os nomes com acentos. O maior nome tem no máximo 80 caracteres. Não existem mais de 1000 crianças na lista. Todos os nomes são distintos. A lista de nomes termina com EOF."
    },
    {
        "nivel": "3",
        "assunto": "3",
        "numero": "2132",
        "saida": "Para cada caso, você deverá imprimir um identificador K, onde K é o número da caso atual. Na linha seguinte imprima a soma dos custos. Após cada caso imprima uma linha em branco.",
        "descricao": "O Canadá é um país muito frio. Em 8 meses por ano as temperaturas praticamente impedem que as ruas sejam ocupadas por vida inteligente, restando apenas criaturas resistentes ao frio como alces, ursos e canadenses (brincadeirinha). Nestes longos meses de inverno famílias buscam diversão em frente de suas lareiras (ou, para as mais corajosas, ao redor de suas fogueiras). A família Smith, de Banff, inventou o jogo que descrevemos a seguir. A brincadeira começa com uma das crianças desenhando um diagrama com estados (representados por bolinhas) ligados por transições (flechas ligando os estados). Cada transição tem uma letra e um número associados. Podemos fazer diversos passeios neste diagrama, partindo de um estado inicio caminhando por suas transições e terminando em um estado final. Um passeio forma uma palavra (obtida da concatenação das letras das transições percorridas) e tem um custo (que é dado pelo produto dos números destas transições). Exemplo, considere o diagrama abaixo. Figura 1: Diagrama Todos os passeios iniciam no estado P e terminam em Q. O passeio que segue pelas transições (P,1A), (P,1A), (P,1B) e termina no estado Q forma a palavra AAB concatenando as letras de cada transição tem custo 1 (produto dos números destas transições). O passeio que segue pelas transições (P,1A), (P,1A), (P,1B), (Q,2B) e termina no estado Q forma a palavra AABB e tem custo 2. O jogo inventado pelo papai Smith era o seguinte. Depois de desenhar um diagrama como esse, um dos membros da família falava uma palavra, e os outros deveriam descobrir a soma dos custos de todos os passeios no diagrama que formam a palavra dada tais que iniciam no estado P e terminam no estado Q. No caso do exemplo do diagrama acima, se o Sr. Smith pedisse a palavra ABA a resposta deveria ser 2.",
        "titulo": "Não é Mais Um Joguinho Canadense!",
        "entrada": "A entrada é composta de diversas palavras (o diagrama é sempre o da figura). Cada caso é dada por uma linha contendo uma palavra. Uma palavra é uma sequência de letras [A, B] com no máximo 60 letras. A entrada termina com final de arquivo (EOF)."
    },
    {
        "nivel": "",
        "assunto": "",
        "numero": "1516",
        "saida": "Para cada caso de teste, imprima A linhas, contendo B caracteres cada, representando o desenho de Rafael redimensionado. Após cada caso de teste, imprima uma linha em branco.",
        "descricao": "Rafael encontrou um novo hobbie: fazer desenhos usando caracteres do teclado. Por mais simples ou limitada que essa nova forma de arte possa parecer, basta criatividade para se fazer os mais diferentes tipos de desenhos. Após fazer alguns desenhos, Rafael imaginou como seriam se eles fossem redimensionados, porém ter que refazer todo o desenho pareceu meio cansativo. Para isso, Rafael pediu sua ajuda. Em um redimensionamento, uma imagem com N linhas e M colunas passa a ter A linhas e B colunas, e, dado que as novas dimensões da imagem redimensionada é maior do que as dimensões da imagem original, alguns caracteres terão que se repetir. Digamos que A seja 3 vezes maior que N. Nesse caso, cada linha terá que se repetir 3 vezes, para que a imagem seja redimensionada de forma correta. Dado um desenho feito por Rafael, imprima como seria se o desenho fosse redimensionado para uma determinada nova dimensão.",
        "titulo": "Imagem",
        "entrada": "Haverá diversos casos de teste. Cada caso de teste inicia com dois inteiros N e M (1 ≤ N, M ≤ 50), representando, respectivamente, a altura e a largura do desenho de Rafael. A seguir haverá N linhas, contendo M caracteres cada, representando o desenho feito por Rafael. Após, haverá dois inteiros A e B (N < A ≤ 100, M < B ≤ 100, A é múltiplo de N, e B é multiplo de M), representando, respectivamente, a nova altura e largura que Rafael deseja que seu desenho tenha. O último caso de teste é indicado quando N = M = 0, o qual não deverá ser processado."
    }
]